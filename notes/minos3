
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .

. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .

. . . . 
A . . . 
A A A . 
. . . . 


function to read minos, and validate minos, then put into a data structure
function to check if we can place/fit a mino
function to check if column is empty
array to keep track of minos
 

(31)go to column
   check if column is empty
	. empty
	.	. check if mino fits
	.		. if mino fits
	.		.	. drop mino
	.		.		. move to next column, goto (31)
	.		.
	.		. if mino doesn't fit	
	.			. (40) check if other mino(s) fit(s)/ in order
	.				. if other mino fits
	.				.	. drop mino
	.				.		. move to next column, use working mino, goto (31)
	.				.
	.				. if other mino doesn't fit
	.					. check if there is another mino
	.						. if there is another mino, goto (40)
	.						.	
	.						. if there are no more minos
	.							. check if there are any empty columns or null  before the current column on the same row
	.							. if there are no empty columns
	.								. move to next column, goto (31)	
	.							. if there are empty columns or null
	.								. revert back to mino which did fit, o.mino
	.								. check if we can move o.mino to the next column
	.									. if we can move o.mino to the next column
	.									.	. move o.mino to the next column
	.									.	. revert to working mino
	.									.	. move to 1st column, goto (31)
	.									.
	.									. if we can't move o.mino to the next column
	.										. check if o.mino reaches end of grid when moved
	.											. if mino doesn't reach end of grid
	.											. 	. move to next column, goto (51)
	.											. if mino does reach end of grid
	.												. check if mino can be moved to next row
	.													. if mino can be moved to next row
	.													.	. move mino
	.													.	. revert back to working mino
	.													.	. move to 1st column, goto (31)	
	.													. if mino can't be moved/end of grid
	.														. remove mino, and revert back to a mino placed before it, to goto (69)
	. !empty
		. move to next column, goto (43)





traverse grid, skip any columns that are filled, if column is empty check if next piece fits, if it
does  place piece, move 1 column repeat
if next piece doesn't fit, check other pieces in order and if a piece fits, place piece, go back to orig. move 1
	if other pieces don't fit, go back to original piece move 1 column, repeat
traverse grid from start

if the next piece doesn't fit because it's end of grid, and piece does not fit, revert back to piece before it and move 
1 column
repeat;



2 minos (4 - 2(1)) = output 3x3 grid
4 minos = output 4x4 grid
8 minos (4 + 2(1) + 2(1)) = ouput 6x6 grid

9  minos (4 + 1(?))
10 minos (4 + 2(1) + 2(1) + 2(1) = output  7x7grid?

